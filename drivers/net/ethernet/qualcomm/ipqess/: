#include <linux/netdevice.h>
#include <linux/phylink.h>
#include <linux/etherdevice.h>
#include <linux/of_net.h>
#include <linux/dsa/qca8k.h>
#include <linux/platform_device.h>
#include <net/rtnetlink.h>

#include "ipqess_port.h"
#include "qca8k_phylink.h"

#define IPQESS_NUM_TX_QUEUES 1

/* netdev ops *******************************************/
static int ipqess_port_open(struct net_device *ndev)
{
	int err;
	//enable port, disable forwarding on it, start phylink
	//...
	return 0;
}

static int ipqess_port_close(struct net_device *ndev)
{
	//stop phylink, disable port
	//...
	return 0;
}

static netdev_tx_t ipqess_port_xmit(struct sk_buff *skb, struct net_device *ndev)
{
	struct sk_buff *nskb;
	struct ipqess_port *port = netdev_priv(ndev);
	struct ipqess_master *master = port->master;

	dev_sw_netstats_tx_add(ndev, 1, skb->len);

	memset(skb->cb, 0, sizeof(skb->cb));
	return ipqess_master_xmit(skb, master, port->index);
}

static int ipqess_port_set_mac_address(struct net_device *ndev, void *a)
{
	struct sockaddr *addr = a;
	int err;

	if (!is_valid_ether_addr(addr->sa_data))
		return -EADDRNOTAVAIL;

	/* If the port is down, the address isn't synced yet to hardware
	 * so there is nothing to change
	 */
	if (!(ndev->flags & IFF_UP)) {
		eth_hw_addr_set(ndev, addr->sa_data);
		return 0;
	}
	
	if (!ether_addr_equal(addr->sa_data, ndev->dev_addr)) {
		err = dev_uc_add(ndev, addr->sa_data);
		if (err < 0)
			return err;
	}

	return 0;
}

static int ipqess_port_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)
{
	struct ipqess_port *port = netdev_priv(ndev);
	return phylink_mii_ioctl(port->pl, ifr, cmd);
}

static const struct net_device_ops ipqess_netdev_ops = {
	.ndo_open	 	= ipqess_port_open,
	.ndo_stop		= ipqess_port_close,
	.ndo_start_xmit		= ipqess_port_xmit,
	.ndo_set_mac_address	= ipqess_port_set_mac_address,
	.ndo_eth_ioctl		= ipqess_port_ioctl,
	/*
	.ndo_set_rx_mode = ipqess_port_set_rx_mode,
	.ndo_fdb_dump		= ipqess_port_fdb_dump,
	.ndo_get_iflink		= ipqess_port_get_iflink,
#ifdef CONFIG_NET_POLL_CONTROLLER
	.ndo_netpoll_setup	= ipqess_port_netpoll_setup,
	.ndo_netpoll_cleanup	= ipqess_port_netpoll_cleanup,
	.ndo_poll_controller	= ipqess_port_poll_controller,
#endif
	.ndo_setup_tc		= ipqess_port_setup_tc,
	.ndo_get_stats64	= ipqess_port_get_stats64,
	.ndo_vlan_rx_add_vid	= ipqess_port_vlan_rx_add_vid,
	.ndo_vlan_rx_kill_vid	= ipqess_port_vlan_rx_kill_vid,
	.ndo_change_mtu		= ipqess_port_change_mtu,
	.ndo_fill_forward_path	= ipqess_port_fill_forward_path,
	*/
};

static int ipqess_port_phy_setup(struct net_device *ndev)
{
	struct ipqess_port *port = netdev_priv(ndev);
	struct device_node *port_dn = port->dn;
	u32 phy_flags = 0;
	int ret;

	port->pl_config.dev = &ndev->dev;
	port->pl_config.type = PHYLINK_NETDEV;
	//see port.c
	err = qca8k_phylink_create(ndev);
	if (err) {
		pr_err("error creating PHYLINK: %d\n", err);
		goto out_free;
	}
}

int ipqess_port_register(struct ipqess_master *master, u16 index,
		struct qca8k_priv *sw_priv)
{
	int err;
	struct net_device *ndev;
	struct device_node *master_node = master->pdev->dev.of_node;
	struct device_node *port_node;
	const char *name;
	int assign_type;
	struct ipqess_port *port;
	pr_info("ipqess_port_register %d\n", index);

	//to cleanup
	port_node = of_find_node_by_path("/soc/switch@c000000/ports/port@4");

	name = of_get_property(port_node, "label", NULL);
	if (name == NULL) {
		name = "eth%d";
		assign_type = NET_NAME_ENUM;
	} else {
		assign_type = NET_NAME_PREDICTABLE;
	}
	ndev = alloc_netdev_mqs(sizeof(struct ipqess_port), name, assign_type,
			ether_setup, IPQESS_NUM_TX_QUEUES, 1);
	if (ndev == NULL)
		return -ENOMEM;
	port = netdev_priv(ndev);
	port->master = master;
	port->index = index;
	port->dn = port_node;
	port->sw_priv = sw_priv;

	err = ipqess_port_phy_setup(ndev);
	if (err) {
		pr_err("error setting up PHY: %d\n", err);
		goto out_free;
	}

	ndev->netdev_ops = &ipqess_netdev_ops;

	rtnl_lock();
	err = register_netdevice(ndev);
	if (err) {
		pr_err("error %d registering interface %s\n",
		err, ndev->name);
		rtnl_unlock();
		goto out_phy;
	}

	rtnl_unlock();

	if (err)
		goto out_unregister;

	return 0;

out_unregister:
	unregister_netdev(ndev);
out_phy:
	rtnl_lock();
	phylink_disconnect_phy(port->pl);
	rtnl_unlock();
	phylink_destroy(port->pl);
	port->pl = NULL;
	/*
out_gcells:
	gro_cells_destroy(&p->gcells);
	*/
out_free:
	free_percpu(ndev->tstats);
	free_netdev(ndev);
	return err;
}
